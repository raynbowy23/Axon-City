/**
 * GeoJSON Export Utility
 * Export area data as GeoJSON with full features and methodology
 */

import type { FeatureCollection, Feature, Polygon } from 'geojson';
import type { ComparisonArea, LayerData } from '../types';
import { layerManifest } from '../data/layerManifest';

interface ExportOptions {
  includeAreaBoundaries: boolean;
  includePOIs: boolean;
  includeBuildings: boolean;
  includeMethodology: boolean;
  separateByLayer: boolean;
}

interface GeoJSONExportResult {
  features: FeatureCollection;
  methodology?: string;
}

/**
 * Generate methodology documentation for reproducibility
 */
function generateMethodology(areas: ComparisonArea[], activeLayers: string[]): string {
  const now = new Date();
  const layerDetails = activeLayers
    .map((id) => {
      const layer = layerManifest.layers.find((l) => l.id === id);
      if (!layer) return null;
      return `### ${layer.name}
- **ID:** ${layer.id}
- **Group:** ${layer.group}
- **Geometry:** ${layer.geometryType}
- **Overpass Query:**
\`\`\`overpass
${layer.osmQuery}
\`\`\``;
    })
    .filter(Boolean)
    .join('\n\n');

  const areaDetails = areas
    .map((area) => {
      const coords = (area.polygon.geometry as Polygon).coordinates[0];
      const coordStr = coords.map(([lng, lat]) => `  [${lng.toFixed(6)}, ${lat.toFixed(6)}]`).join(',\n');
      return `### ${area.name}
- **Area:** ${(area.polygon.area / 1_000_000).toFixed(4)} km²
- **Coordinates (GeoJSON format):**
\`\`\`json
[
${coordStr}
]
\`\`\``;
    })
    .join('\n\n');

  return `# AxonCity Data Export

## Export Information
- **Date:** ${now.toISOString()}
- **Timezone:** ${Intl.DateTimeFormat().resolvedOptions().timeZone}
- **Areas Exported:** ${areas.length}
- **Layers Included:** ${activeLayers.length}

## Data Sources
- **Primary Source:** OpenStreetMap via Overpass API
- **API Endpoint:** https://overpass-api.de/api/interpreter
- **License:** Open Database License (ODbL) 1.0

## Attribution
Data © OpenStreetMap contributors. Available under the Open Database License.
https://www.openstreetmap.org/copyright

## Areas

${areaDetails}

## Layer Definitions

${layerDetails}

## Metrics Methodology

### POI Density
- **Formula:** count / area_km²
- **Unit:** features per km²

### Diversity Index (Shannon Entropy)
- **Formula:** H = -Σ(pᵢ × ln(pᵢ))
- **Where:** pᵢ = proportion of features in category i

### Area Share
- **Formula:** (feature_area / total_area) × 100
- **Unit:** percentage

## Reproducibility

To reproduce this analysis:
1. Use the Overpass API queries listed above
2. Clip results to the area boundaries provided
3. Calculate metrics using the formulas specified

## Tool Information
- **Generated by:** AxonCity (https://axoncity.com)
- **Version:** 1.0.0
`;
}

/**
 * Convert ComparisonArea to GeoJSON feature
 */
function areaToFeature(area: ComparisonArea): Feature {
  return {
    type: 'Feature',
    geometry: area.polygon.geometry,
    properties: {
      id: area.id,
      name: area.name,
      area_m2: area.polygon.area,
      area_km2: area.polygon.area / 1_000_000,
      color: `rgb(${area.color[0]}, ${area.color[1]}, ${area.color[2]})`,
      type: 'area_boundary',
    },
  };
}

/**
 * Merge all layer features into a single FeatureCollection
 */
function mergeLayerFeatures(
  areas: ComparisonArea[],
  activeLayers: string[],
  options: ExportOptions
): FeatureCollection {
  const allFeatures: Feature[] = [];

  // Add area boundaries
  if (options.includeAreaBoundaries) {
    for (const area of areas) {
      allFeatures.push(areaToFeature(area));
    }
  }

  // Add layer features
  for (const area of areas) {
    for (const [layerId, layerData] of area.layerData) {
      if (!activeLayers.includes(layerId)) continue;

      const layer = layerManifest.layers.find((l) => l.id === layerId);
      if (!layer) continue;

      // Filter by geometry type if options specified
      const isBuilding = layer.group === 'infrastructure' && layer.geometryType === 'polygon';
      const isPOI = layer.geometryType === 'point';

      if (isBuilding && !options.includeBuildings) continue;
      if (isPOI && !options.includePOIs) continue;

      // Use clipped features if available, otherwise use raw features
      const features = layerData.clippedFeatures || layerData.features;

      for (const feature of features.features) {
        // Enhance feature properties
        allFeatures.push({
          ...feature,
          properties: {
            ...feature.properties,
            _axoncity_layer: layerId,
            _axoncity_layer_name: layer.name,
            _axoncity_area: area.name,
            _axoncity_area_id: area.id,
            _axoncity_group: layer.group,
          },
        });
      }
    }
  }

  return {
    type: 'FeatureCollection',
    features: allFeatures,
  };
}

/**
 * Export areas as separate GeoJSON files (returns a map of filename -> content)
 */
export function exportSeparateGeoJSON(
  areas: ComparisonArea[],
  activeLayers: string[]
): Map<string, string> {
  const files = new Map<string, string>();

  // Export each area separately
  for (const area of areas) {
    const areaFeatures: Feature[] = [areaToFeature(area)];

    for (const [layerId, layerData] of area.layerData) {
      if (!activeLayers.includes(layerId)) continue;

      const layer = layerManifest.layers.find((l) => l.id === layerId);
      const features = layerData.clippedFeatures || layerData.features;

      for (const feature of features.features) {
        areaFeatures.push({
          ...feature,
          properties: {
            ...feature.properties,
            _layer: layerId,
            _layer_name: layer?.name,
          },
        });
      }
    }

    const fc: FeatureCollection = {
      type: 'FeatureCollection',
      features: areaFeatures,
    };

    const filename = `${area.name.toLowerCase().replace(/\s+/g, '-')}.geojson`;
    files.set(filename, JSON.stringify(fc, null, 2));
  }

  return files;
}

/**
 * Export all data as a single GeoJSON file
 */
export function exportGeoJSON(
  areas: ComparisonArea[],
  activeLayers: string[],
  options: Partial<ExportOptions> = {}
): GeoJSONExportResult {
  const fullOptions: ExportOptions = {
    includeAreaBoundaries: true,
    includePOIs: true,
    includeBuildings: true,
    includeMethodology: true,
    separateByLayer: false,
    ...options,
  };

  const features = mergeLayerFeatures(areas, activeLayers, fullOptions);
  const methodology = fullOptions.includeMethodology
    ? generateMethodology(areas, activeLayers)
    : undefined;

  return { features, methodology };
}

/**
 * Download GeoJSON file
 */
export function downloadGeoJSON(
  areas: ComparisonArea[],
  activeLayers: string[],
  options: Partial<ExportOptions> = {}
): void {
  const { features, methodology } = exportGeoJSON(areas, activeLayers, options);

  // Generate filename
  const areaNames = areas.map((a) => a.name.toLowerCase().replace(/\s+/g, '-')).join('-vs-');
  const date = new Date().toISOString().split('T')[0];
  const baseFilename = `axoncity-${areaNames}-${date}`;

  // Download GeoJSON
  const geoJsonBlob = new Blob([JSON.stringify(features, null, 2)], {
    type: 'application/geo+json',
  });
  downloadBlob(geoJsonBlob, `${baseFilename}.geojson`);

  // Download methodology if included
  if (methodology) {
    const methodologyBlob = new Blob([methodology], { type: 'text/markdown' });
    downloadBlob(methodologyBlob, `${baseFilename}-methodology.md`);
  }
}

/**
 * Download a single GeoJSON with just area boundaries
 */
export function downloadAreaBoundaries(areas: ComparisonArea[]): void {
  const features: FeatureCollection = {
    type: 'FeatureCollection',
    features: areas.map(areaToFeature),
  };

  const areaNames = areas.map((a) => a.name.toLowerCase().replace(/\s+/g, '-')).join('-vs-');
  const blob = new Blob([JSON.stringify(features, null, 2)], {
    type: 'application/geo+json',
  });
  downloadBlob(blob, `axoncity-boundaries-${areaNames}.geojson`);
}

/**
 * Helper to download a blob
 */
function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  link.style.display = 'none';
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

/**
 * Get export statistics
 */
export function getExportStats(
  areas: ComparisonArea[],
  activeLayers: string[]
): { totalFeatures: number; layerCounts: Record<string, number> } {
  let totalFeatures = 0;
  const layerCounts: Record<string, number> = {};

  for (const area of areas) {
    for (const [layerId, layerData] of area.layerData) {
      if (!activeLayers.includes(layerId)) continue;

      const count = (layerData.clippedFeatures || layerData.features).features.length;
      totalFeatures += count;
      layerCounts[layerId] = (layerCounts[layerId] || 0) + count;
    }
  }

  return { totalFeatures, layerCounts };
}
